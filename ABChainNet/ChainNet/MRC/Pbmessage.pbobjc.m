// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PBMessage.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Pbmessage.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PbmessageRoot

@implementation PbmessageRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - PbmessageRoot_FileDescriptor

static GPBFileDescriptor *PbmessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com_ab_message"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - VersionMessage

@implementation VersionMessage

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;
@dynamic hasVersion, version;
@dynamic hasServices, services;
@dynamic hasSubVer, subVer;
@dynamic hasId_p, id_p;
@dynamic hasSessionId, sessionId;

typedef struct VersionMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  int32_t version;
  NSString *messageId;
  NSString *replyId;
  NSString *subVer;
  NSString *id_p;
  NSString *sessionId;
  int64_t timestamp;
  int64_t services;
} VersionMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = VersionMessage_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VersionMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = VersionMessage_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VersionMessage__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = VersionMessage_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VersionMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = VersionMessage_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VersionMessage__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = VersionMessage_FieldNumber_Version,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VersionMessage__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "services",
        .dataTypeSpecific.className = NULL,
        .number = VersionMessage_FieldNumber_Services,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VersionMessage__storage_, services),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "subVer",
        .dataTypeSpecific.className = NULL,
        .number = VersionMessage_FieldNumber_SubVer,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VersionMessage__storage_, subVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = VersionMessage_FieldNumber_Id_p,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VersionMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = VersionMessage_FieldNumber_SessionId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(VersionMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VersionMessage class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VersionMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\003\t\000\004\007\000\007\006\000\t\010A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMMessage

@implementation IMMessage

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;
@dynamic hasVersion, version;
@dynamic hasServices, services;
@dynamic hasSubVer, subVer;
@dynamic hasId_p, id_p;
@dynamic hasImjson, imjson;

typedef struct IMMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  int32_t version;
  NSString *messageId;
  NSString *replyId;
  NSString *subVer;
  NSString *id_p;
  NSString *imjson;
  int64_t timestamp;
  int64_t services;
} IMMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMMessage__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IMMessage__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_Version,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IMMessage__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "services",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_Services,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IMMessage__storage_, services),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "subVer",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_SubVer,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(IMMessage__storage_, subVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_Id_p,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(IMMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imjson",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_Imjson,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(IMMessage__storage_, imjson),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMessage class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\003\t\000\004\007\000\007\006\000\tc\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DiscoverMessage

@implementation DiscoverMessage

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;

typedef struct DiscoverMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  NSString *messageId;
  NSString *replyId;
  int64_t timestamp;
} DiscoverMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverMessage_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DiscoverMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverMessage_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DiscoverMessage__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverMessage_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DiscoverMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverMessage_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DiscoverMessage__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DiscoverMessage class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DiscoverMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\t\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DiscoverReplyMessage

@implementation DiscoverReplyMessage

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;
@dynamic peerAddressArray, peerAddressArray_Count;

typedef struct DiscoverReplyMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  NSString *messageId;
  NSString *replyId;
  NSMutableArray *peerAddressArray;
  int64_t timestamp;
} DiscoverReplyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverReplyMessage_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DiscoverReplyMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverReplyMessage_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DiscoverReplyMessage__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverReplyMessage_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DiscoverReplyMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverReplyMessage_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DiscoverReplyMessage__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "peerAddressArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DiscoverReplyMessage_PeerAddress),
        .number = DiscoverReplyMessage_FieldNumber_PeerAddressArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DiscoverReplyMessage__storage_, peerAddressArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeGroup,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DiscoverReplyMessage class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DiscoverReplyMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\t\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DiscoverReplyMessage_PeerAddress

@implementation DiscoverReplyMessage_PeerAddress

@dynamic hasIp, ip;
@dynamic hasPort, port;
@dynamic hasServices, services;
@dynamic hasId_p, id_p;

typedef struct DiscoverReplyMessage_PeerAddress__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSString *ip;
  NSString *id_p;
  int64_t services;
} DiscoverReplyMessage_PeerAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverReplyMessage_PeerAddress_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DiscoverReplyMessage_PeerAddress__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverReplyMessage_PeerAddress_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DiscoverReplyMessage_PeerAddress__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "services",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverReplyMessage_PeerAddress_FieldNumber_Services,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DiscoverReplyMessage_PeerAddress__storage_, services),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = DiscoverReplyMessage_PeerAddress_FieldNumber_Id_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DiscoverReplyMessage_PeerAddress__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DiscoverReplyMessage_PeerAddress class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DiscoverReplyMessage_PeerAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DiscoverReplyMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PingMessage

@implementation PingMessage

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;
@dynamic hasNonce, nonce;

typedef struct PingMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  NSString *messageId;
  NSString *replyId;
  int64_t timestamp;
  int64_t nonce;
} PingMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PingMessage_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PingMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = PingMessage_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PingMessage__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = PingMessage_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PingMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = PingMessage_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PingMessage__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = PingMessage_FieldNumber_Nonce,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PingMessage__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PingMessage class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PingMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\t\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PongMessage

@implementation PongMessage

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;
@dynamic hasNonce, nonce;

typedef struct PongMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  NSString *messageId;
  NSString *replyId;
  int64_t timestamp;
  int64_t nonce;
} PongMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PongMessage_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PongMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = PongMessage_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PongMessage__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = PongMessage_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PongMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = PongMessage_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PongMessage__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = PongMessage_FieldNumber_Nonce,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PongMessage__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PongMessage class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PongMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\t\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindMessage

@implementation FindMessage

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;
@dynamic hasReqAddress, reqAddress;
@dynamic hasAimAddress, aimAddress;
@dynamic hasReqId, reqId;
@dynamic hasAimId, aimId;
@dynamic hasResourceType, resourceType;
@dynamic hasCondition, condition;

typedef struct FindMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  NSString *messageId;
  NSString *replyId;
  FindMessage_ReqAddress *reqAddress;
  FindMessage_AimAddress *aimAddress;
  NSString *reqId;
  NSString *aimId;
  NSString *resourceType;
  NSData *condition;
  int64_t timestamp;
} FindMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FindMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FindMessage__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FindMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FindMessage__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reqAddress",
        .dataTypeSpecific.className = GPBStringifySymbol(FindMessage_ReqAddress),
        .number = FindMessage_FieldNumber_ReqAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FindMessage__storage_, reqAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "aimAddress",
        .dataTypeSpecific.className = GPBStringifySymbol(FindMessage_AimAddress),
        .number = FindMessage_FieldNumber_AimAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FindMessage__storage_, aimAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "reqId",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_FieldNumber_ReqId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FindMessage__storage_, reqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aimId",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_FieldNumber_AimId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FindMessage__storage_, aimId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resourceType",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_FieldNumber_ResourceType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FindMessage__storage_, resourceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "condition",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_FieldNumber_Condition,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(FindMessage__storage_, condition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindMessage class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FindMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\003\t\000\004\007\000\007\005\000\010\005\000\t\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindMessage_ReqAddress

@implementation FindMessage_ReqAddress

@dynamic hasIp, ip;
@dynamic hasPort, port;

typedef struct FindMessage_ReqAddress__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSString *ip;
} FindMessage_ReqAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_ReqAddress_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FindMessage_ReqAddress__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_ReqAddress_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FindMessage_ReqAddress__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindMessage_ReqAddress class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FindMessage_ReqAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(FindMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindMessage_AimAddress

@implementation FindMessage_AimAddress

@dynamic hasIp, ip;
@dynamic hasPort, port;

typedef struct FindMessage_AimAddress__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSString *ip;
} FindMessage_AimAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_AimAddress_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FindMessage_AimAddress__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = FindMessage_AimAddress_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FindMessage_AimAddress__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindMessage_AimAddress class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FindMessage_AimAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(FindMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindAckMessage

@implementation FindAckMessage

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;
@dynamic hasAeqAddress, aeqAddress;
@dynamic hasAimAddress, aimAddress;
@dynamic hasReqId, reqId;
@dynamic hasAimId, aimId;
@dynamic hasResult, result;

typedef struct FindAckMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  NSString *messageId;
  NSString *replyId;
  FindAckMessage_AeqAddress *aeqAddress;
  FindAckMessage_AimAddress *aimAddress;
  NSString *reqId;
  NSString *aimId;
  FindAckMessage_Result *result;
  int64_t timestamp;
} FindAckMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FindAckMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FindAckMessage__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FindAckMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FindAckMessage__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aeqAddress",
        .dataTypeSpecific.className = GPBStringifySymbol(FindAckMessage_AeqAddress),
        .number = FindAckMessage_FieldNumber_AeqAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FindAckMessage__storage_, aeqAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "aimAddress",
        .dataTypeSpecific.className = GPBStringifySymbol(FindAckMessage_AimAddress),
        .number = FindAckMessage_FieldNumber_AimAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FindAckMessage__storage_, aimAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "reqId",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_FieldNumber_ReqId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FindAckMessage__storage_, reqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aimId",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_FieldNumber_AimId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FindAckMessage__storage_, aimId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "result",
        .dataTypeSpecific.className = GPBStringifySymbol(FindAckMessage_Result),
        .number = FindAckMessage_FieldNumber_Result,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FindAckMessage__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindAckMessage class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FindAckMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\003\t\000\004\007\000\007\005\000\010\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindAckMessage_AeqAddress

@implementation FindAckMessage_AeqAddress

@dynamic hasIp, ip;
@dynamic hasPort, port;

typedef struct FindAckMessage_AeqAddress__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSString *ip;
} FindAckMessage_AeqAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_AeqAddress_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FindAckMessage_AeqAddress__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_AeqAddress_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FindAckMessage_AeqAddress__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindAckMessage_AeqAddress class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FindAckMessage_AeqAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(FindAckMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindAckMessage_AimAddress

@implementation FindAckMessage_AimAddress

@dynamic hasIp, ip;
@dynamic hasPort, port;

typedef struct FindAckMessage_AimAddress__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSString *ip;
} FindAckMessage_AimAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_AimAddress_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FindAckMessage_AimAddress__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_AimAddress_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FindAckMessage_AimAddress__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindAckMessage_AimAddress class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FindAckMessage_AimAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(FindAckMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindAckMessage_Result

@implementation FindAckMessage_Result

@dynamic hasData_p, data_p;

typedef struct FindAckMessage_Result__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
} FindAckMessage_Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = FindAckMessage_Result_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FindAckMessage_Result__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindAckMessage_Result class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FindAckMessage_Result__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(FindAckMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction

@implementation Transaction

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;
@dynamic hasReqAddress, reqAddress;
@dynamic hasAimAddress, aimAddress;
@dynamic hasReqId, reqId;
@dynamic hasAimId, aimId;
@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;
@dynamic unlockScriptsArray, unlockScriptsArray_Count;
@dynamic hasVersion, version;
@dynamic hasUpdatedAt, updatedAt;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  int32_t version;
  NSString *messageId;
  NSString *replyId;
  Transaction_ReqAddress *reqAddress;
  Transaction_AimAddress *aimAddress;
  NSString *reqId;
  NSString *aimId;
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
  NSMutableArray *unlockScriptsArray;
  int64_t timestamp;
  uint64_t updatedAt;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reqAddress",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_ReqAddress),
        .number = Transaction_FieldNumber_ReqAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, reqAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "aimAddress",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_AimAddress),
        .number = Transaction_FieldNumber_AimAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, aimAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "reqId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_ReqId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction__storage_, reqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aimId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_AimId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction__storage_, aimId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Inputs),
        .number = Transaction_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Outputs),
        .number = Transaction_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "unlockScriptsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_UnlockScripts),
        .number = Transaction_FieldNumber_UnlockScriptsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, unlockScriptsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Version,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Transaction__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "updatedAt",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_UpdatedAt,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Transaction__storage_, updatedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\003\t\000\004\007\000\007\005\000\010\005\000\r\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_ReqAddress

@implementation Transaction_ReqAddress

@dynamic hasIp, ip;
@dynamic hasPort, port;

typedef struct Transaction_ReqAddress__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSString *ip;
} Transaction_ReqAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ReqAddress_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_ReqAddress__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ReqAddress_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_ReqAddress__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_ReqAddress class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_ReqAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_AimAddress

@implementation Transaction_AimAddress

@dynamic hasIp, ip;
@dynamic hasPort, port;

typedef struct Transaction_AimAddress__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSString *ip;
} Transaction_AimAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_AimAddress_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_AimAddress__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_AimAddress_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_AimAddress__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_AimAddress class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_AimAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Inputs

@implementation Transaction_Inputs

@dynamic hasSequence, sequence;
@dynamic hasInputType, inputType;
@dynamic hasTradeInput, tradeInput;
@dynamic hasIssueInput, issueInput;

typedef struct Transaction_Inputs__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Inputs_InputType inputType;
  Transaction_Inputs_TradeInput *tradeInput;
  Transaction_Inputs_IssueInput *issueInput;
  int64_t sequence;
} Transaction_Inputs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sequence",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Inputs_FieldNumber_Sequence,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Inputs__storage_, sequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "inputType",
        .dataTypeSpecific.enumDescFunc = Transaction_Inputs_InputType_EnumDescriptor,
        .number = Transaction_Inputs_FieldNumber_InputType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Inputs__storage_, inputType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "tradeInput",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Inputs_TradeInput),
        .number = Transaction_Inputs_FieldNumber_TradeInput,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Inputs__storage_, tradeInput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "issueInput",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Inputs_IssueInput),
        .number = Transaction_Inputs_FieldNumber_IssueInput,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Inputs__storage_, issueInput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Inputs class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Inputs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Transaction_Inputs_InputType

GPBEnumDescriptor *Transaction_Inputs_InputType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IssueType\000TradeType\000";
    static const int32_t values[] = {
        Transaction_Inputs_InputType_IssueType,
        Transaction_Inputs_InputType_TradeType,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Inputs_InputType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Inputs_InputType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_Inputs_InputType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_Inputs_InputType_IssueType:
    case Transaction_Inputs_InputType_TradeType:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Transaction_Inputs_TradeInput

@implementation Transaction_Inputs_TradeInput

@dynamic hasOutpoint, outpoint;

typedef struct Transaction_Inputs_TradeInput__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Inputs_TradeInput_Outpoint *outpoint;
} Transaction_Inputs_TradeInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outpoint",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Inputs_TradeInput_Outpoint),
        .number = Transaction_Inputs_TradeInput_FieldNumber_Outpoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Inputs_TradeInput__storage_, outpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Inputs_TradeInput class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Inputs_TradeInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction_Inputs)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Inputs_TradeInput_Outpoint

@implementation Transaction_Inputs_TradeInput_Outpoint

@dynamic hasHash_p, hash_p;
@dynamic hasIndex, index;
@dynamic hasIsSpend, isSpend;

typedef struct Transaction_Inputs_TradeInput_Outpoint__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Inputs_TradeInput_Outpoint_Hash *hash_p;
  int64_t index;
} Transaction_Inputs_TradeInput_Outpoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Inputs_TradeInput_Outpoint_Hash),
        .number = Transaction_Inputs_TradeInput_Outpoint_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Inputs_TradeInput_Outpoint__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Inputs_TradeInput_Outpoint_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Inputs_TradeInput_Outpoint__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isSpend",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Inputs_TradeInput_Outpoint_FieldNumber_IsSpend,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Inputs_TradeInput_Outpoint class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Inputs_TradeInput_Outpoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction_Inputs_TradeInput)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Inputs_TradeInput_Outpoint_Hash

@implementation Transaction_Inputs_TradeInput_Outpoint_Hash

@dynamic hasBytes, bytes;

typedef struct Transaction_Inputs_TradeInput_Outpoint_Hash__storage_ {
  uint32_t _has_storage_[1];
  NSData *bytes;
} Transaction_Inputs_TradeInput_Outpoint_Hash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bytes",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Inputs_TradeInput_Outpoint_Hash_FieldNumber_Bytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Inputs_TradeInput_Outpoint_Hash__storage_, bytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Inputs_TradeInput_Outpoint_Hash class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Inputs_TradeInput_Outpoint_Hash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction_Inputs_TradeInput_Outpoint)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Inputs_IssueInput

@implementation Transaction_Inputs_IssueInput

@dynamic hasSourceType, sourceType;
@dynamic hasData_p, data_p;

typedef struct Transaction_Inputs_IssueInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *sourceType;
  NSData *data_p;
} Transaction_Inputs_IssueInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceType",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Inputs_IssueInput_FieldNumber_SourceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Inputs_IssueInput__storage_, sourceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Inputs_IssueInput_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Inputs_IssueInput__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Inputs_IssueInput class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Inputs_IssueInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction_Inputs)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Outputs

@implementation Transaction_Outputs

@dynamic hasTimestamp, timestamp;
@dynamic hasMinimum, minimum;
@dynamic hasMessageId, messageId;
@dynamic hasReplyId, replyId;
@dynamic hasScriptBytes, scriptBytes;
@dynamic hasValue, value;

typedef struct Transaction_Outputs__storage_ {
  uint32_t _has_storage_[1];
  int32_t minimum;
  NSString *messageId;
  NSString *replyId;
  NSData *scriptBytes;
  NSData *value;
  int64_t timestamp;
} Transaction_Outputs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Outputs_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Outputs__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Outputs_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Outputs__storage_, minimum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Outputs_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Outputs__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replyId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Outputs_FieldNumber_ReplyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Outputs__storage_, replyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scriptBytes",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Outputs_FieldNumber_ScriptBytes,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction_Outputs__storage_, scriptBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Outputs_FieldNumber_Value,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction_Outputs__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Outputs class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Outputs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\t\000\004\007\000\005\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_UnlockScripts

@implementation Transaction_UnlockScripts

@dynamic hasScriptBytes, scriptBytes;
@dynamic hasOutpoint, outpoint;
@dynamic hasSequence, sequence;

typedef struct Transaction_UnlockScripts__storage_ {
  uint32_t _has_storage_[1];
  NSData *scriptBytes;
  Transaction_UnlockScripts_Outpoint *outpoint;
  int64_t sequence;
} Transaction_UnlockScripts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "scriptBytes",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_UnlockScripts_FieldNumber_ScriptBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_UnlockScripts__storage_, scriptBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "outpoint",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_UnlockScripts_Outpoint),
        .number = Transaction_UnlockScripts_FieldNumber_Outpoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_UnlockScripts__storage_, outpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_UnlockScripts_FieldNumber_Sequence,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_UnlockScripts__storage_, sequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_UnlockScripts class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_UnlockScripts__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_UnlockScripts_Outpoint

@implementation Transaction_UnlockScripts_Outpoint

@dynamic hasHash_p, hash_p;
@dynamic hasIndex, index;
@dynamic hasIsSpend, isSpend;

typedef struct Transaction_UnlockScripts_Outpoint__storage_ {
  uint32_t _has_storage_[1];
  Transaction_UnlockScripts_Outpoint_Hash *hash_p;
  int64_t index;
} Transaction_UnlockScripts_Outpoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_UnlockScripts_Outpoint_Hash),
        .number = Transaction_UnlockScripts_Outpoint_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_UnlockScripts_Outpoint__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeGroup,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_UnlockScripts_Outpoint_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_UnlockScripts_Outpoint__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isSpend",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_UnlockScripts_Outpoint_FieldNumber_IsSpend,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_UnlockScripts_Outpoint class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_UnlockScripts_Outpoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction_UnlockScripts)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_UnlockScripts_Outpoint_Hash

@implementation Transaction_UnlockScripts_Outpoint_Hash

@dynamic hasBytes, bytes;

typedef struct Transaction_UnlockScripts_Outpoint_Hash__storage_ {
  uint32_t _has_storage_[1];
  NSData *bytes;
} Transaction_UnlockScripts_Outpoint_Hash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bytes",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_UnlockScripts_Outpoint_Hash_FieldNumber_Bytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_UnlockScripts_Outpoint_Hash__storage_, bytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_UnlockScripts_Outpoint_Hash class]
                                     rootClass:[PbmessageRoot class]
                                          file:PbmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_UnlockScripts_Outpoint_Hash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction_UnlockScripts_Outpoint)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
